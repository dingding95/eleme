# 存储-封锁机制

​		在多用户共享系统中,许多事务可能同时对同一数据进行操作,称为"并发操作",此时数据库管理系统的并发控制子系统负责协调并发事务的执行,保证数据库的完整性不受破坏,同时避免用户得到不正确的数据。

  **1.并发操作的问题**（多个人同时对一个数据进行操作）

 数据库的并发操作带来的问题:丢失更新问题,不一致分析问题(读过时的数据),依赖于未提交更新的问题(读了"脏"数据)。这三个问题需要DBMS的并发控制子系统来解决。

  (1)  丢失更新(丢失修改)

​	例：两个人同时读取并修改统一数据			

（2）读过时的数据（不可重复读）：

​	例：AB同时读取数据，B读取数据是修改了数值，A再读取时与第一次读取的值不一样

（3）读"脏"数据。

​	例：T1把C由100改为200,T1读到C为200,而事务T1由于被撤销，其修改宣布无效，C恢复为原值100,而T2却读到了C为200,与数据库内容不一致。

​			
**2.封锁技术**  

处理并发控制的主要方法是采用封锁技术。有两种封锁：X封锁和S封锁。

（1）排他型封锁（简称X封锁）：如果事务T对数据A（可以是数据项、记录、数据集以至整个
数据库）实现了X封锁，那么只允许事务T读取和修改数据A,其他事务要等事务T解除X封锁以后，才
能对数据A实现任何类型的封锁。可见X封锁只允许一个事务独锁某个数据，具有排他性。

**只允许一个人对数据进行操作（增删改）**



（2）共享型封锁（简称S封锁）：X封锁只允许一个事务独锁和使用数据，要求太严。需要适当
从宽，例如可以允许并发读，但不允许修改，这就产生了S封锁概念。S封锁的含义是如果事务T对数
据A实现了S封锁，那么允许事务T读取数据A,但不能修改数据A,在所有S封锁解除之前决不允许任何
事务对数据A实现X封锁。所谓封锁的粒度即是被封锁数据目标的大小，在关系数据库中封锁粒度有属性值、属性值集、
元组、关系、某索引项（或整个索引）、整个关系数据库、物理页（块）等几种。封锁粒度小则并发性高，但开销大；封锁粒度大则并发性低，但开销小，综合平衡照顾不同需求以合理选取适当的封锁的粒度是很重要的。

**允许多个人同时对数据进行操作（查）**



**3.封锁协议**  

在多个事务并发执行的系统中，主要采取封锁协议来进行处理。
（1）一级封锁协议：事务T在修改数据R之前必须先对其加X锁，直到事务结束才释放。一级封
锁协议可防止丢失修改，并保证事务T是可恢复的。但不能保证可重复读和不读"脏"数据。
（2）二级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，读完后即可释放S
锁。二级封锁协议可防止丢失修改，还可防止读"脏"数据。但不能保证可重复读。
（3）三级封锁协议：一级封锁协议加上事务T在读取数据R之前先对其加S锁，直到事务结束才
释放。三级封锁协议可防止丢失修改、防止读"脏"数据与数据重复读。
（4）两段锁协议：所有事务必须分两个阶段对数据项加锁和解锁。其中扩展阶段是在对任何数
据进行读、写操作之前，首先要申请并获得对该数据的封锁；收缩阶段是在释放一个封锁之后，事
务不能再申请和获得任何其他封锁。若并发执行的所有事务均遵守两段封锁协议，则对这些事务的
任何并发调度策略都是可串行化的。遵守两段封锁协议的事务可能发生死锁。



**4.死锁**  

采用封锁的方法固然可以有效防止数据的不一致性，但封锁本身也会产生一些麻烦，最主要就
是死锁问题。所谓死锁即是多个用户申请不同封锁，由于申请者均拥有一部分封锁权而又需等待另外用户拥有的部分封锁而引起的永无休止的等待。一般讲，死锁是可以避免的，目前采用的办法有
如下几种：
（1）预防法：此种方法即是采用一定的操作方式以保证避免死锁的出现，顺序申请法，一次申
请法等即是此类方法。所谓顺序申请法即是对封锁对象按序编号。用户申请封锁时必须按编号顺序
（从小到大或反之）申请，这样能避免死锁发生。所谓一次申请法即是用户在一个完整操作过程中
必须一次性申请它所需要的所有封锁，并在操作结束后一次性归还所有封锁，这样世能避免死锁的
发生。
（2）解除法：此种方法即是允许产生死锁，并在死锁产生后通过解锁程序以解除死锁。这种方
法中需要有两个程序，一是死锁检测程序，用它以测定死锁是否发生，另一是解锁程序，一旦经测
定系统已产生死锁则启动解锁程序以解除死锁。
​	



​		
​	
​	
​		
​			
​				



​				
​			
​		
​	

